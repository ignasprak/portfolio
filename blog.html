<!DOCTYPE html>
<html lang="en">

<!-- WEB PROPERTIES -->

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ignas Prakapas</title>
    <link rel="stylesheet" href="style.css" />
    <link />
    <script src="script.js"></script>
</head>

<!-- WEBSITE START -->

<body>

    <!-- NAVBAR -->

    <nav class="nav-menu">
        <div class="nav-left">
            <button class="hamburger nav-left" id="hamburger" aria-label="Toggle navigation">☰</button>
            <h1 style="font-size: xx-large;">Ignas Prakapas</h1>
        </div>

        <ul class="nav-links" id="nav-links">
            <li><a href="./index.html">Home</a></li>
            <li><a href="./projects.html">Projects</a></li>
            <li><a href="./blog.html">Blog</a></li>
            <li><a href="https://github.com/ignasprak">GitHub</a></li>
            <li><a href="https://www.linkedin.com/in/ignas-p-520086211/">LinkedIn</a></li>
            <li>
                <button class="dark-mode-toggle" id="darkModeToggle" aria-label="Toggle dark mode">
                    <img id="themeIcon" src="media/dark-moon.png" alt="Toggle Dark Mode" />
                </button>

            </li>

        </ul>

    </nav>

    <div class="box-in">
        <h1>My Blog</h1>
        <br> <br>
        <!-- BLOG_POSTS_START -->

        <article class="blog-post">
            <h1>DataTalksClub - Day 2</h1>
            <p class="post-date">August 20, 2025</p>
            <div class="post-tags">#dataengineering #datatalksclub</div>

            <h2>Connecting pgAdmin and Postgres (1.2.3)</h2>

            <p>We can quickly take a look at the data in pgcli, we can connect to the DB and do commands such as:</p>

            <pre><code>SELECT max(tpep_pickup_datetime), MAX(total_amount)
FROM yellow_taxi_data;</code></pre>

            <p>PgAdmin is a more convenient tool when looking at our DB, it is a web-based GUI SQL tool.</p>

            <p>We do not need to install it, instead we can use docker to pull an image of PgAdmin.</p>

            <ul>
                <li><a href="https://www.pgadmin.org/download/pgadmin-4-container/">pgAdmin 4 Container Download</a>
                </li>
                <li><a href="https://hub.docker.com/r/dpage/pgadmin4/">Docker Hub - pgAdmin4</a></li>
            </ul>

            <p>To do this we can run the command:</p>

            <div class="command-block">docker run -it \
                -e PGADMIN_DEFAULT_EMAIL="admin@admin.com" \
                -e PGADMIN_DEFAULT_PASSWORD="root" \
                -p 8080:80 \
                dpage/pgadmin4</div>

            <p><code>-p 8080:80</code> means whatever we send to port 8080, this will be forwarded to port 80 on docker
            </p>

            <p>So then we can go to <code>localhost:8080</code> on the browser and login to create a new server, but we
                cannot do that because now we need to link the two containers.</p>

            <h3>Creating Docker Networks</h3>

            <p>We can do this by using networks. First we shut down the containers, and create a network by doing:</p>

            <div class="command-block">docker network create pg-network</div>

            <p>Then run the containers with the network:</p>

            <div class="command-block">docker run -it \
                -e POSTGRES_USER="root" \
                -e POSTGRES_PASSWORD="root" \
                -e POSTGRES_DB="ny_taxi" \
                -v "/Users/ignasprakapas/Coding
                Projects/data-engineering/data-engineering-zoomcamp/01-docker-terraform/2_docker_sql/ny_taxi_postgres_data":/var/lib/postgresql/data
                \
                -p 5432:5432 \
                --network=pg-network \
                --name pg-database \
                postgres:13</div>

            <div class="command-block">docker run -it \
                -e PGADMIN_DEFAULT_EMAIL="admin@admin.com" \
                -e PGADMIN_DEFAULT_PASSWORD="root" \
                -p 8080:80 \
                --network=pg-network \
                --name pgadmin \
                dpage/pgadmin4</div>

            <p>Now after we run the containers again, we can create the server and refer to the postgres database as
                <strong>pg-database</strong> when it comes to the host name/address.
            </p>
        </article>

        <article class="blog-post">
            <h1>Data Engineering Roadmap - Python</h1>
            <p class="post-date">August 18, 2025</p>
            <div class="post-tags">#python #roadmap</div>

            <h2>Python Fundamentals</h2>

            <h3>1.1 Introduction</h3>
            <p>An <code>input()</code> function always returns a string. You can convert it using <code>int()</code> or
                <code>float()</code>.
            </p>

            <p><strong>Example:</strong></p>
            <pre><code>age = int(input("Enter your age: "))</code></pre>

            <h3>1.2 Data Types</h3>

            <h4>Numeric Types</h4>
            <p>Python has three numeric types:</p>
            <ul>
                <li>Integers</li>
                <li>Floats</li>
                <li>Complex numbers</li>
            </ul>

            <h4>Strings</h4>
            <p>Strings are <strong>immutable</strong>, meaning their values cannot be changed. Common string operations
                include concatenation, slicing, and formatting.</p>

            <pre><code>str1 = "Data"
str2 = "Engineering"

# Concatenation
combined_str = str1 + " " + str2
print(combined_str)  # Output: Data Engineering

# Slicing
substring = combined_str[0:4]
print(substring)  # Output: Data

# Formatting
formatted_string = "I am learning {}".format(combined_str)
print(formatted_string)  # Output: I am learning Data Engineering</code></pre>

            <h3>Python's Data Structures</h3>

            <h4>Lists</h4>
            <p>Mutable collections of items, defined using square brackets:</p>

            <pre><code>my_list = [1, 2, 3, "apple", "banana"]

print(type(my_list))  # Output: &lt;class 'list'&gt;
print(my_list[0])     # Output: 1 (first element)
print(my_list[-1])    # Output: banana (last element)

# Add an element to the end
my_list.append("cherry")
print(my_list)  # Output: [1, 2, 3, 'apple', 'banana', 'cherry']

# Insert an element at a specific index
my_list.insert(2, "orange")
print(my_list)  # Output: [1, 2, 'orange', 3, 'apple', 'banana', 'cherry']

# Remove a specific element
my_list.remove("apple")
print(my_list)  # Output: [1, 2, 'orange', 3, 'banana', 'cherry']

# Remove and return an element at a specific index
popped_element = my_list.pop(1)
print(my_list)        # Output: [1, 'orange', 3, 'banana', 'cherry']
print(popped_element) # Output: 2

# Modify an element
my_list[0] = 10
print(my_list)  # Output: [10, 'orange', 3, 'banana', 'cherry']</code></pre>

            <h4>Dictionaries</h4>
            <pre><code>my_dict = {
    "name": "Alice",
    "age": 30,
    "city": "New York"
}

print(type(my_dict))      # Output: &lt;class 'dict'&gt;
print(my_dict["name"])    # Output: Alice
print(my_dict.get("age")) # Output: 30</code></pre>

            <h4>Sets</h4>
            <pre><code>my_set = {1, 2, 3, 4, 5}
my_set2 = set([4, 5, 6, 7])

print(type(my_set))  # Output: &lt;class 'set'&gt;

my_set.add(6)        # Add an element
print(my_set)        # Output: {1, 2, 3, 4, 5, 6}

my_set.remove(1)     # Remove an element
print(my_set)        # Output: {2, 3, 4, 5, 6}

# Set operations
union_set = my_set.union(my_set2)
intersection_set = my_set.intersection(my_set2)
difference_set = my_set.difference(my_set2)</code></pre>

            <h4>Data Structure Comparison</h4>
            <table>
                <tr>
                    <th>Data Structure</th>
                    <th>Lists</th>
                    <th>Tuples</th>
                    <th>Dictionaries</th>
                    <th>Sets</th>
                </tr>
                <tr>
                    <td>Mutable</td>
                    <td>Yes</td>
                    <td>No</td>
                    <td>Yes</td>
                    <td>Yes</td>
                </tr>
                <tr>
                    <td>Defined</td>
                    <td>[]</td>
                    <td>()</td>
                    <td>{} (key-value)</td>
                    <td>{} or set()</td>
                </tr>
                <tr>
                    <td>Performance</td>
                    <td>Standard</td>
                    <td>Fastest</td>
                    <td>Standard</td>
                    <td>Standard</td>
                </tr>
                <tr>
                    <td>Main Use</td>
                    <td>Editing</td>
                    <td>Performance</td>
                    <td>Storing & Retrieving</td>
                    <td>Math Operations</td>
                </tr>
            </table>

            <div class="highlight">
                <strong>Key Takeaways:</strong>
                <ul>
                    <li>Dictionaries are ideal for storing config settings for data pipelines</li>
                    <li>The set operator can be used to quickly remove duplicate entries</li>
                </ul>
            </div>

            <h3>Control Flow</h3>

            <h4>If Statements</h4>
            <ul>
                <li><code>if</code></li>
                <li><code>elif</code></li>
                <li><code>else</code></li>
            </ul>

            <p>You can also do nested if statements:</p>

            <pre><code>raining = True
temperature = 15

if raining:
    if temperature &lt; 10:
        print("It's a cold and rainy day.")
    else:
        print("It's a rainy day.")  # This line will be executed
else:
    print("It's not raining.")</code></pre>

            <h4>Loops</h4>

            <h5>For Loops</h5>
            <p>Used to iterate over a sequence (list, tuple, string, or range):</p>
            <ul>
                <li><code>range(start, stop, step)</code> is used to iterate a certain number of times</li>
                <li>Nested for loops are used for matrices</li>
            </ul>

            <pre><code>matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]

for row in matrix:
    for element in row:
        print(element)  # Prints each element of the matrix</code></pre>

            <h5>While Loops</h5>
            <p>Keep looping as long as a certain condition is true.</p>
        </article>

        <article class="blog-post">
            <h1>DataTalksClub - Day 1</h1>
            <p class="post-date">August 11, 2025</p>
            <div class="post-tags">#dataengineering #datatalksclub</div>

            <h2>Intro to Docker (1.2.1)</h2>

            <div class="highlight">
                <strong>Note:</strong> CI/CD is not covered in this course, make sure to look at this at a later date.
            </div>

            <p><strong>Docker is useful because:</strong></p>
            <ul>
                <li>Local experimentation</li>
                <li>Integration testing (CI/CD)</li>
                <li>Reproducibility</li>
                <li>Running pipelines on the cloud (AWS Batch, Kubernetes)</li>
                <li>Spark (defining data pipelines, used to define dependencies)</li>
                <li>Serverless (AWS Lambda, processing data one record at a time)</li>
            </ul>

            <h3>Docker Basics</h3>

            <div class="command-block">docker run -it ubuntu bash</div>

            <ul>
                <li><code>docker</code> is the base command for using Docker</li>
                <li><code>run</code> means to execute an image</li>
                <li><code>-it</code> means to run in an interactive terminal</li>
                <li><code>ubuntu</code> is the name of the image we want to run</li>
                <li><code>bash</code> is the command we want to execute in this image (parameter)</li>
            </ul>

            <p>Running this image, deleting everything, and running it again returns it to its original state because it
                is isolated.</p>

            <div class="command-block">docker run -it python:3.9</div>

            <ul>
                <li><code>python</code> is the name of the image</li>
                <li><code>3.9</code> is the tag (version)</li>
            </ul>

            <div class="command-block">docker run -it --entrypoint=bash python:3.9</div>

            <p>In order to install modules, we can use <code>pip install pandas</code>, but we need to go to a bash
                terminal since we cannot do this in Python.</p>

            <h3>Docker in VS Code</h3>

            <p>When creating our own container, we need specifications for our Dockerfile, starting with the base image:
            </p>

            <pre><code>FROM python:3.9</code></pre>

            <p>Then we can do a run command:</p>

            <pre><code>RUN pip install pandas</code></pre>

            <p>Since we can only install pandas in bash and not Python:</p>

            <pre><code>ENTRYPOINT [ "bash" ]</code></pre>

            <p>To build this image from VS Code using the Docker file:</p>

            <div class="command-block">docker build -t test:pandas .</div>

            <ul>
                <li><code>build</code> tells Docker to build the image</li>
                <li><code>.</code> means to build it in the current directory</li>
            </ul>

            <p>Then when that is done, you can run it by using:</p>

            <div class="command-block">docker run -it test:pandas</div>

            <h3>Data Pipeline</h3>

            <p>We can now create a Python file (.py):</p>

            <pre><code>import pandas as pd
# Whatever fancy stuff it will be doing
print('Yay job done')</code></pre>

            <p>Then in our Dockerfile we add:</p>

            <pre><code>COPY pipeline.py pipeline.py</code></pre>

            <p>This copies the file to the Docker container. We can also specify the work directory:</p>

            <pre><code>WORKDIR /app</code></pre>

            <h4>Data Pipeline - Automation</h4>

            <p>To the pipeline file we add:</p>

            <pre><code>import sys
print(sys.argv)
day = sys.argv[1]
print(f'Job done good for day = {day}')</code></pre>

            <p>Then in the Dockerfile:</p>

            <pre><code>ENTRYPOINT [ "python", "pipeline.py" ]</code></pre>

            <p>You build the container, and then run it:</p>

            <div class="command-block">docker run -it test:pandas 2025-08-10</div>

            <p>This is how to parameterize the data pipeline scripts:</p>

            <div class="command-block">docker run -it test:pandas 2025-08-10 123 hello</div>

            <h2>Ingesting NY Taxi Data to Postgres (1.2.2)</h2>

            <h3>Docker Compose</h3>

            <p>We have:</p>
            <ul>
                <li><strong>Environment variables:</strong> we use a <code>-e</code> flag for this
                    (postgres_user/password/db)</li>
                <li><strong>Volumes:</strong> a way of mapping folder in host machine file system to a folder in a
                    container (mounting), we use a <code>-v</code> flag for this (needs full path on Windows machines)
                </li>
                <li><strong>Ports:</strong> we need to specify a port on our host machine to a port on the container
                    (needed to send requests to the DB), we use a <code>-p</code> for this (5432:5432)</li>
            </ul>

            <p>From the tutorial section we put this code into the terminal to run it:</p>

            <div class="command-block">docker run -it \
                -e POSTGRES_USER="root" \
                -e POSTGRES_PASSWORD="root" \
                -e POSTGRES_DB="ny_taxi" \
                -v "/Users/ignasprakapas/Coding
                Projects/data-engineering/data-engineering-zoomcamp/01-docker-terraform/2_docker_sql/ny_taxi_postgres_data":/var/lib/postgresql/data
                \
                -p 5432:5432 \
                postgres:13</div>

            <p>Now we want to access the database (pip install pgcli):</p>

            <div class="command-block">pgcli -h localhost -p 5432 -u root -d ny_taxi</div>

            <div class="highlight">
                <strong>Troubleshooting:</strong> Sometimes port 5432 is already in use by a previous container. On Mac:
                <br><code>sudo lsof -i -P | grep LISTEN | grep :$PORT</code> to list ports in use
                <br><code>sudo kill -9 (PID)</code> to kill the process
            </div>

            <p>When we are in the container using pgcli, we can do:</p>
            <ul>
                <li><code>\dt</code> - to list the tables</li>
            </ul>

            <p>We are going to use Jupyter now. To install: <code>pip install jupyter</code>, then run
                <code>jupyter notebook</code>
            </p>

            <h3>Working with Data</h3>

            <p>We're now working with .parquet files instead of .csv files → just replace <code>read_csv</code> with
                <code>read_parquet</code> and remove the nrows argument.
            </p>

            <p>When looking at a .csv file you can look at it using the <code>less</code> command.</p>

            <p><strong>Some handy data commands:</strong></p>
            <ul>
                <li><code>head -n 100 xyz.csv > xyz_head.csv</code> = get the top 100 lines and convert that into a new
                    file</li>
                <li><code>wc -l xyz.csv</code> = counts the number of rows in the .csv file, the -l specifies lines</li>
            </ul>

            <p><strong>Datasets used:</strong></p>
            <ul>
                <li><a href="https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2021-01.parquet">Yellow
                        Taxi Data (January 2021)</a></li>
                <li><a href="https://www.nyc.gov/assets/tlc/downloads/pdf/data_dictionary_trip_records_yellow.pdf">Data
                        Dictionary</a></li>
                <li><a href="https://d37ci6vzurychx.cloudfront.net/misc/taxi_zone_lookup.csv">Taxi Zone Lookup Table</a>
                </li>
            </ul>

            <h3>Processing the Data</h3>

            <p>Since the file was in .parquet format, we had to use .parquet and work with that in Jupyter:</p>

            <pre><code>import pandas as pd
!pip install pyarrow
import urllib.request
import pyarrow.parquet as pq

# Download the file
url = 'https://d37ci6vzurychx.cloudfront.net/trip-data/yellow_tripdata_2021-01.parquet'
filename = 'yellow_tripdata_2021-01.parquet'
urllib.request.urlretrieve(url, filename)
print("File downloaded")

# Read the data
parquet_file = pq.ParquetFile(filename)
trips_df = parquet_file.read(use_pandas_metadata=True).slice(0, 100).to_pandas()

trips_df</code></pre>

            <h3>Creating Database Schema</h3>

            <p>Now we want to put this data into our Postgres. We need to turn this into a schema using Data Definition
                Language (DDL):</p>

            <pre><code>print(pd.io.sql.get_schema(trips_df, name="yellow_taxi_data"))</code></pre>

            <p>We notice in the schema that what are meant to be timestamps are in text format, so we need to convert
                them:</p>

            <pre><code>trips_df.tpep_pickup_datetime = pd.to_datetime(trips_df.tpep_pickup_datetime)
trips_df.tpep_dropoff_datetime = pd.to_datetime(trips_df.tpep_dropoff_datetime)</code></pre>

            <p>Then we need to import sqlalchemy:</p>

            <pre><code>from sqlalchemy import create_engine

engine = create_engine('postgresql://root:root@localhost:5432/ny_taxi')
engine.connect()

# Updated schema with connection
print(pd.io.sql.get_schema(trips_df, name="yellow_taxi_data", con=engine))</code></pre>

            <h3>Batch Processing</h3>

            <p>Since this is a large dataset, we can do batch processing using an iterator:</p>

            <pre><code># Create iterator
parquet_file = pq.ParquetFile('yellow_tripdata_2021-01.parquet')
df_iter = parquet_file.iter_batches(batch_size=100000)

# Get first chunk
df = next(df_iter).to_pandas()

# Check length
len(df)

# Convert datetime columns
df.tpep_pickup_datetime = pd.to_datetime(df.tpep_pickup_datetime)
df.tpep_dropoff_datetime = pd.to_datetime(df.tpep_dropoff_datetime)

# Show headers
df.head(n=0)</code></pre>

            <h3>Inserting Data</h3>

            <p>Now we insert the table and then the data chunk by chunk. There is a function in dataframes called
                <code>to_sql</code>:
            </p>

            <pre><code># Create table structure
trips_df.head(n=0).to_sql(name='yellow_taxi_data', con=engine, if_exists='replace')

# Insert data in chunks
%time df_iter = parquet_file.iter_batches(batch_size=100000)

for i, batch in enumerate(df_iter):
    chunk_df = batch.to_pandas()
    
    # Convert datetime columns
    chunk_df.tpep_pickup_datetime = pd.to_datetime(chunk_df.tpep_pickup_datetime)
    chunk_df.tpep_dropoff_datetime = pd.to_datetime(chunk_df.tpep_dropoff_datetime)
    
    print(f"Inserting chunk {i+1} with {len(chunk_df)} rows...")
    
    # Insert chunk
    %time chunk_df.to_sql(name='yellow_taxi_data', con=engine, if_exists='append')
    
    print(f"Finished inserting chunk {i+1}")</code></pre>

            <p><strong>This concludes my learning for the day!</strong></p>
        </article>

        <article class="blog-post">
            <hr>
            <br>
            <h2>Data Engineering - Day 1</h2>
            <br>
            <p class="post-date">2025-08-09</p>
            <br>
            <div class="post-content">
                <p>Today I start my first day of the DataTalksClub course that I will be doing on my own, without any
                    intention of getting a certificate and purely to learn about the fundamentals of data engineering.
                </p>
            </div>
        </article>
        <br> <br>

        <!-- BLOG_POSTS_END -->
</body>

</body>

</html>